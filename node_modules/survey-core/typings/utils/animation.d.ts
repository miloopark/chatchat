export interface AnimationOptions {
    cssClass: string;
    onBeforeRunAnimation?: (element: HTMLElement) => void;
    onAfterRunAnimation?: (element: HTMLElement) => void;
}
export interface IAnimationConsumer<T extends Array<any> = []> {
    getLeaveOptions(...args: T): AnimationOptions;
    getEnterOptions(...args: T): AnimationOptions;
    getAnimatedElement(...args: T): HTMLElement;
    isAnimationEnabled(): boolean;
}
export declare class AnimationUtils {
    private getMsFromRule;
    private getAnimationsCount;
    private getAnimationDuration;
    private cancelQueue;
    protected onAnimationEnd(element: HTMLElement, callback: (isCancel?: boolean) => void, options: AnimationOptions): void;
    protected beforeAnimationRun(element: HTMLElement, options: AnimationOptions | AnimationOptions): void;
    protected runLeaveAnimation(element: HTMLElement, options: AnimationOptions, callback: () => void): void;
    protected runEnterAnimation(element: HTMLElement, options: AnimationOptions): void;
    cancel(): void;
}
export declare class AnimationPropertyUtils extends AnimationUtils {
    onEnter(getElement: () => HTMLElement, options: AnimationOptions): void;
    onLeave(getElement: () => HTMLElement, callback: () => void, options: AnimationOptions): void;
}
export declare class AnimationGroupUtils<T> extends AnimationUtils {
    onEnter(getElement: (el: T) => HTMLElement, getOptions: (el: T) => AnimationOptions, elements: Array<T>): void;
    onLeave(getElement: (el: T) => HTMLElement, callback: () => void, getOptions: (el: T) => AnimationOptions, elements: Array<T>): void;
}
declare abstract class AnimationProperty<T, S extends Array<any> = []> {
    protected animationOptions: IAnimationConsumer<S>;
    protected update: (val: T) => void;
    protected getCurrentValue: () => T;
    constructor(animationOptions: IAnimationConsumer<S>, update: (val: T) => void, getCurrentValue: () => T);
    protected animation: AnimationUtils;
    protected abstract _sync(newValue: T): void;
    private _debouncedSync;
    sync(newValue: T): void;
    cancel(): void;
}
export declare class AnimationBoolean extends AnimationProperty<boolean> {
    protected animation: AnimationPropertyUtils;
    protected _sync(newValue: boolean): void;
}
export declare class AnimationGroup<T> extends AnimationProperty<Array<T>, [T]> {
    protected animation: AnimationGroupUtils<T>;
    protected _sync(newValue: Array<T>): void;
}
export {};
